- name: Create portable registry directories
  file:
    path: "{{ item.path }}"
    state: directory
  with_items:
    - { path: "/opt/registry/auth" }
    - { path: "/opt/registry/certs" }
          #        - { path: "../ssl/csr" }
  when: internet_type == 'A'

- name: Create certificate for registry
  shell:
    cmd: "openssl req -newkey rsa:4096 -nodes -sha256 -keyout /opt/registry/certs/bastion.repo.pem -x509 -days 365 -out /opt/registry/certs/bastion.repo.crt -subj \"/C=PL/ST=Miedzyrzecz/L=/O=Test /OU=Test/CN=registry.{{ domain }}\" -addext \"subjectAltName = DNS:registry.{{ domain }}\""
  when: internet_type == 'A'

- name: Copy CA cert to Centos PKI
  copy:
    src: /opt/registry/certs/bastion.repo.crt
    dest: /etc/pki/ca-trust/source/anchors/
  when: internet_type == 'A'

- name: Register self-signed CA
  shell:
    cmd: update-ca-trust extract
  when: internet_type == 'A'

- name: Cleanup httpasswd file
  file:
    path: /opt/registry/auth/bastion.repo.htpasswd
    state: absent
  when: internet_type == 'A'

- name: Create htpasswd file
  htpasswd:
    path: /opt/registry/auth/bastion.repo.htpasswd
    name: "{{ repo_user }}"
    crypt_scheme: bcrypt
    password: "{{ repo_user_password }}"
  when: internet_type == 'A'

- name: Start firewall
  service:
    name: firewalld
    state: started
    enabled: yes

- name: Open ports on bastion for offline installation
  firewalld:
    port: "{{ item.port }}/{{ item.type }}"
    permanent: yes
    immediate: yes
    state: enabled
  with_items:
    - { port: "5000", type: "tcp" }
  when: internet_type == 'A'

- name: Open ports on bastion for offline installation
  firewalld:
    service: http
    permanent: yes
    state: enabled

- name: Load image registry into local repository
  shell:
    cmd: "podman load -i {{ temp_dir }}/coreos/oc-registry.tar"
  when: internet_type == 'A'

- name: Check image repository existence
  shell:
    cmd: podman ps -a|grep bastion-registry|wc -l
  register: is_repo_available
  when: internet_type == 'A'

- name: Remove existing bastion image registry container
  shell:
    cmd: "{{ item }}"
  loop:
    - podman stop bastion-registry
    - "podman container prune <<< 'Y'"
  when: internet_type == 'A' and is_repo_available.stdout == '1'

- name: Setup image registry
  shell:
    cmd: 'podman run -d --name bastion-registry -p 5000:5000 -v /opt/registry/data:/var/lib/registry:z -v /opt/registry/auth:/auth:z -e "REGISTRY_AUTH=htpasswd" -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry" -e "REGISTRY_HTTP_SECRET=ALongRandomSecretForRegistry" -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/bastion.repo.htpasswd -v /opt/registry/certs:/certs:z -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/bastion.repo.crt -e REGISTRY_HTTP_TLS_KEY=/certs/bastion.repo.pem docker.io/library/registry:{{ registry_version }}'
    chdir: /opt/registry
  when: internet_type == 'A'

- name: Set SELINUX permissive access for NetworkManager
  shell:
    cmd: semanage permissive -a NetworkManager_t

- name: Install ansible galaxy packages
  shell:
    cmd: ansible-galaxy collection install community.general
  when: install_ldap == 'Y' and internet_type != 'A'

- name: Cleanup configuration files
  file:
    path: "{{ item.path }}"
    state: absent
  with_items:
    - { path: "/etc/systemd/system/matchbox.service" }
    - { path: "/usr/local/bin/matchbox" }
    - { path: "/var/lib/matchbox" }
    - { path: "/var/lib/tftp" }
    - { path: "../ocp" }

- name: Set variable for public SSH key
  shell: >
    cat "{{ ssh_key }}.pub"
  register: ssh_pub_key

- name: Check original resolved.conf file existence
  stat:
    path: "/etc/systemd/resolved.conf.orig"
  register: resolved_config_presence

- name: Check original nsswitch.conf file existence
  stat:
    path: "/etc/nsswitch.conf.orig"
  register: nsswitch_config_presence

- name: Copy original nsswitch.conf file
  copy:
    src: "/etc/nsswitch.conf"
    dest: "/etc/nsswitch.conf.orig"
  when: nsswitch_config_presence.stat.exists == false

- name: Restore original nsswitch.conf file
  copy:
    src: "/etc/nsswitch.conf.orig"
    dest: "/etc/nsswitch.conf"
  when: nsswitch_config_presence.stat.exists == true

- name: Unlink resolv.conf
  file:
    path: "/etc/resolv.conf"
    state: absent

- name: Link resolv.conf
  file:
    src: "/run/systemd/resolve/resolv.conf"
    dest: "/etc/resolv.conf"
    state: link

- name: Clean TFTP directory
  file:
    path: "/var/lib/tftp"
    state: absent

- name: Create TFTP directory
  file:
    path: "/var/lib/tftp"
    state: directory
    mode: '0755'

- name: Add the user 'matchbox'
  user:
    name: matchbox

- name: Clean matchbox directory
  file:
    path: "/var/lib/matchbox"
    state: absent

- name: Create Matchbox directories
  file:
    path: "{{ item.path }}"
    state: directory
    mode: "0755"
    owner: matchbox
    group: matchbox
  with_items:
    - { path: "/var/lib/matchbox" }
    - { path: "/var/lib/matchbox/assets" }
    - { path: "/var/lib/matchbox/groups" }
    - { path: "/var/lib/matchbox/ignition" }
    - { path: "/var/lib/matchbox/profiles" }

- name: Check matchbox package presence
  stat:
    path: "{{ temp_dir }}/coreos/matchbox-{{ matchbox_version }}-linux-amd64.tar.gz"
  register: matchbox_presence

- name: Stop if matchbox not uploaded for air-gapped installation
  fail:
    msg: "Please upload matchbox to download directory"
  when: internet_type == 'A' and matchbox_presence.stat.exists == false

- name: Download matchbox
  get_url:
    url: "https://github.com/poseidon/matchbox/releases/download/{{ matchbox_version }}/matchbox-{{ matchbox_version }}-linux-amd64.tar.gz"
    dest: "{{ temp_dir }}"
    use_proxy: "{{ 'yes' if internet_type == 'P' else 'no' }}"
  when: matchbox_presence.stat.exists == false and internet_type != 'A'

- name: Unzip matchbox
  command:
    cmd: "tar zxf {{ temp_dir }}/coreos/matchbox-{{ matchbox_version }}-linux-amd64.tar.gz -C {{ temp_dir }}"
  args:
    warn: false

- name: Copy matchbox to bin
  copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: root
    group: root
    mode: 0755
  with_items:
    - { src: "{{ temp_dir }}/matchbox-v0.9.0-linux-amd64/matchbox", dest: "/usr/local/bin" }

- name: Copy matchbox service file
  copy:
    src: "{{ temp_dir }}/matchbox-v0.9.0-linux-amd64/contrib/systemd/matchbox.service"
    dest: "/etc/systemd/system/matchbox.service"
    owner: root
    mode: 0644

- name: Start and enable matchbox
  service:
    name: matchbox
    state: restarted
    enabled: yes

- name: Clean matchbox temp directory
  file:
    path: "{{ temp_dir }}/matchbox-v0.9.0-linux-amd64"
    state: absent

- name: Check original chrony config file existence
  stat:
    path: "/etc/chrony.conf.orig"
    register: chrony_config_presence

- name: Restore original chrony config file
  copy:
    dest: /etc/chrony.conf
    src: /etc/chrony.conf.orig
  when: chrony_config_presence.stat.exists == true

- name: Copy original chrony config file
  copy:
    src: /etc/chrony.conf
    dest: /etc/chrony.conf.orig
  when: chrony_config_presence.stat.exists == false

- name: Modify chrony.conf
  lineinfile:
    path: /etc/chrony.conf
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
  with_items:
    - { regexp: '^#allow 192.168.0.0/16', line: "allow all" }
    - { regexp: '^#local stratum 10', line: "local stratum 10" }
  when: ntp_server == bas_ip

- name: Set SE Linux for chronyd
  shell:
    cmd: semanage permissive -a chronyd_t
  when: ntp_server == bas_ip and false

- name: Start and enable chronyd
  service:
  name: chronyd
    state: restarted
    enabled: yes
  when: ntp_server == bas_ip
